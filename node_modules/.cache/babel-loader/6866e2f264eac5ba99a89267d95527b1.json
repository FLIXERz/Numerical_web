{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode } from '../../utils/is.js';\nimport { keywords } from '../keywords.js';\nimport { escape } from '../../utils/string.js';\nimport { forEach, join } from '../../utils/array.js';\nimport { toSymbol } from '../../utils/latex.js';\nimport { getPrecedence } from '../operators.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'FunctionAssignmentNode';\nvar dependencies = ['typed', 'Node'];\nexport var createFunctionAssignmentNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    Node\n  } = _ref;\n  /**\n   * Is parenthesis needed?\n   * @param {Node} node\n   * @param {Object} parenthesis\n   * @param {string} implicit\n   * @private\n   */\n  function needParenthesis(node, parenthesis, implicit) {\n    var precedence = getPrecedence(node, parenthesis, implicit);\n    var exprPrecedence = getPrecedence(node.expr, parenthesis, implicit);\n    return parenthesis === 'all' || exprPrecedence !== null && exprPrecedence <= precedence;\n  }\n  class FunctionAssignmentNode extends Node {\n    /**\n     * @constructor FunctionAssignmentNode\n     * @extends {Node}\n     * Function assignment\n     *\n     * @param {string} name           Function name\n     * @param {string[] | Array.<{name: string, type: string}>} params\n     *                                Array with function parameter names, or an\n     *                                array with objects containing the name\n     *                                and type of the parameter\n     * @param {Node} expr             The function expression\n     */\n    constructor(name, params, expr) {\n      super();\n      // validate input\n      if (typeof name !== 'string') {\n        throw new TypeError('String expected for parameter \"name\"');\n      }\n      if (!Array.isArray(params)) {\n        throw new TypeError('Array containing strings or objects expected for parameter \"params\"');\n      }\n      if (!isNode(expr)) {\n        throw new TypeError('Node expected for parameter \"expr\"');\n      }\n      if (keywords.has(name)) {\n        throw new Error('Illegal function name, \"' + name + '\" is a reserved keyword');\n      }\n      var paramNames = new Set();\n      for (var param of params) {\n        var _name = typeof param === 'string' ? param : param.name;\n        if (paramNames.has(_name)) {\n          throw new Error(\"Duplicate parameter name \\\"\".concat(_name, \"\\\"\"));\n        } else {\n          paramNames.add(_name);\n        }\n      }\n      this.name = name;\n      this.params = params.map(function (param) {\n        return param && param.name || param;\n      });\n      this.types = params.map(function (param) {\n        return param && param.type || 'any';\n      });\n      this.expr = expr;\n    }\n    get type() {\n      return name;\n    }\n    get isFunctionAssignmentNode() {\n      return true;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      var childArgNames = Object.create(argNames);\n      forEach(this.params, function (param) {\n        childArgNames[param] = true;\n      });\n\n      // compile the function expression with the child args\n      var evalExpr = this.expr._compile(math, childArgNames);\n      var name = this.name;\n      var params = this.params;\n      var signature = join(this.types, ',');\n      var syntax = name + '(' + join(this.params, ', ') + ')';\n      return function evalFunctionAssignmentNode(scope, args, context) {\n        var signatures = {};\n        signatures[signature] = function () {\n          var childArgs = Object.create(args);\n          for (var i = 0; i < params.length; i++) {\n            childArgs[params[i]] = arguments[i];\n          }\n          return evalExpr(scope, childArgs, context);\n        };\n        var fn = typed(name, signatures);\n        fn.syntax = syntax;\n        scope.set(name, fn);\n        return fn;\n      };\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      callback(this.expr, 'expr', this);\n    }\n\n    /**\n     * Create a new FunctionAssignmentNode whose children are the results of\n     * calling the provided callback function for each child of the original\n     * node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {FunctionAssignmentNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      var expr = this._ifNode(callback(this.expr, 'expr', this));\n      return new FunctionAssignmentNode(this.name, this.params.slice(0), expr);\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {FunctionAssignmentNode}\n     */\n    clone() {\n      return new FunctionAssignmentNode(this.name, this.params.slice(0), this.expr);\n    }\n\n    /**\n     * get string representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var expr = this.expr.toString(options);\n      if (needParenthesis(this, parenthesis, options && options.implicit)) {\n        expr = '(' + expr + ')';\n      }\n      return this.name + '(' + this.params.join(', ') + ') = ' + expr;\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      var types = this.types;\n      return {\n        mathjs: name,\n        name: this.name,\n        params: this.params.map(function (param, index) {\n          return {\n            name: param,\n            type: types[index]\n          };\n        }),\n        expr: this.expr\n      };\n    }\n\n    /**\n     * Instantiate an FunctionAssignmentNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     ```\n     *     {\"mathjs\": \"FunctionAssignmentNode\",\n     *      name: ..., params: ..., expr: ...}\n     *     ```\n     *     where mathjs is optional\n     * @returns {FunctionAssignmentNode}\n     */\n    static fromJSON(json) {\n      return new FunctionAssignmentNode(json.name, json.params, json.expr);\n    }\n\n    /**\n     * get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var params = [];\n      for (var i = 0; i < this.params.length; i++) {\n        params.push('<span class=\"math-symbol math-parameter\">' + escape(this.params[i]) + '</span>');\n      }\n      var expr = this.expr.toHTML(options);\n      if (needParenthesis(this, parenthesis, options && options.implicit)) {\n        expr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + expr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n      return '<span class=\"math-function\">' + escape(this.name) + '</span>' + '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + params.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' + '<span class=\"math-operator math-assignment-operator ' + 'math-variable-assignment-operator math-binary-operator\">=</span>' + expr;\n    }\n\n    /**\n     * get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var expr = this.expr.toTex(options);\n      if (needParenthesis(this, parenthesis, options && options.implicit)) {\n        expr = \"\\\\left(\".concat(expr, \"\\\\right)\");\n      }\n      return '\\\\mathrm{' + this.name + '}\\\\left(' + this.params.map(toSymbol).join(',') + '\\\\right)=' + expr;\n    }\n  }\n  _defineProperty(FunctionAssignmentNode, \"name\", name);\n  return FunctionAssignmentNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":null,"metadata":{},"sourceType":"module"}