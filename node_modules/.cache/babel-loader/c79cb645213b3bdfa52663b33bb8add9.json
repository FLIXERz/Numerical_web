{"ast":null,"code":"import * as math from 'mathjs';\nconst i_arr = [];\nconst a_arr = [];\nconst b_arr = [];\nconst root_arr = [];\nexport default function Bisection_method(a, b, eq) {\n  let Error_rate = 0.0000001;\n  function func(x) {\n    const node2 = math.parse(eq);\n    const code2 = node2.compile();\n    let scope = {\n      x\n    };\n    return code2.evaluate(scope);\n    // return  x*x*x*x-13;\n  }\n  function mid(ax, bx) {\n    let mids = (ax + bx) / 2;\n    return mids;\n  }\n  let i = 0;\n  let xm = a;\n  // while((b-a) >= Error_rate)\n  while (math.abs(b - a) / b * 100 >= Error_rate) {\n    a_arr.push(a);\n    b_arr.push(b);\n    xm = mid(a, b);\n    if (func(xm) === 0.0) {\n      // Check if middle point is root\n      break;\n    } else if (func(xm) * func(a) < 0) {\n      // Decide the side to repeat the steps\n      b = xm;\n    } else {\n      a = xm;\n    }\n    i++;\n    i_arr.push(i);\n    root_arr.push(xm);\n  }\n  return xm;\n  // return console.log(xm) ;\n}\nexport function DataTable(x) {\n  const data = [];\n  const datax = [];\n  for (let i = 0; i < i_arr.length; i++) {\n    datax.push({\n      iter: i_arr[i],\n      x0: a_arr[i],\n      x1: b_arr[i],\n      xm: root_arr[i]\n    });\n  }\n  for (let i = 0; i < i_arr.length; i++) {\n    data.push(datax[i]);\n  }\n  if (x === 1) {\n    // Clear the existing data\n    data.length = 0;\n    datax.length = 0;\n    i_arr.length = 0;\n    a_arr.length = 0;\n    b_arr.length = 0;\n    root_arr.length = 0;\n  }\n  return data;\n  //    return console.log(data) ;\n}\n//Testcase\n// let a=1.5,b=2\n// Bisection_method(a,b);\n// DataTable();","map":{"version":3,"names":["math","i_arr","a_arr","b_arr","root_arr","Bisection_method","a","b","eq","Error_rate","func","x","node2","parse","code2","compile","scope","evaluate","mid","ax","bx","mids","i","xm","abs","push","DataTable","data","datax","length","iter","x0","x1"],"sources":["C:/Users/Azul/homework/Numerical/1/PJ/src/Components/Testbisec.js"],"sourcesContent":["import * as math from 'mathjs';\r\n\r\nconst i_arr =[]\r\nconst a_arr = []\r\nconst b_arr = []\r\nconst root_arr = [] \r\n\r\nexport default function Bisection_method(a,b,eq){\r\n    let Error_rate = 0.0000001;\r\n    \r\n    function func(x)\r\n        {\r\n            const node2 = math.parse(eq)\r\n            const code2 = node2.compile()\r\n            let scope = {x} \r\n            return  code2.evaluate(scope);\r\n            // return  x*x*x*x-13;\r\n        } \r\n    function mid(ax,bx){\r\n        let mids=(ax+bx)/2;\r\n        return mids\r\n    }\r\n    let i=0;\r\n    let xm = a;\r\n    // while((b-a) >= Error_rate)\r\n    while((math.abs(b-a)/b)*100 >= Error_rate)\r\n    {   a_arr.push(a);\r\n        b_arr.push(b);\r\n        \r\n        xm = mid(a,b);\r\n\r\n        if(func(xm) === 0.0){// Check if middle point is root\r\n                break;\r\n        }\r\n        else if(func(xm) * func(a) < 0){// Decide the side to repeat the steps\r\n            b = xm;\r\n        }\r\n        else{\r\n            a = xm;\r\n        }\r\n        i++\r\n        i_arr.push(i);\r\n        root_arr.push(xm);\r\n    }\r\n    return xm ;\r\n    // return console.log(xm) ;\r\n}\r\n\r\n\r\nexport function DataTable(x){\r\n    const data =[]\r\n    const datax =[]\r\n    for (let i = 0; i < i_arr.length; i++) {\r\n        datax.push({iter:i_arr[i],x0:a_arr[i],x1:b_arr[i],xm:root_arr[i]});\r\n      }\r\n    for (let i = 0; i < i_arr.length; i++) {\r\n        data.push(datax[i])\r\n    }\r\n    if(x === 1){\r\n        // Clear the existing data\r\n        data.length = 0;\r\n        datax.length = 0;\r\n        i_arr.length = 0;\r\n        a_arr.length = 0;\r\n        b_arr.length = 0 ;\r\n        root_arr.length = 0;\r\n    }\r\n        \r\n\r\n   return data;\r\n//    return console.log(data) ;\r\n}\r\n//Testcase\r\n// let a=1.5,b=2\r\n// Bisection_method(a,b);\r\n// DataTable();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}