{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isArrayNode, isNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'ArrayNode';\nvar dependencies = ['Node'];\nexport var createArrayNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  class ArrayNode extends Node {\n    /**\n     * @constructor ArrayNode\n     * @extends {Node}\n     * Holds an 1-dimensional array with items\n     * @param {Node[]} [items]   1 dimensional array with items\n     */\n    constructor(items) {\n      super();\n      this.items = items || [];\n\n      // validate input\n      if (!Array.isArray(this.items) || !this.items.every(isNode)) {\n        throw new TypeError('Array containing Nodes expected');\n      }\n    }\n    get type() {\n      return name;\n    }\n    get isArrayNode() {\n      return true;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      var evalItems = map(this.items, function (item) {\n        return item._compile(math, argNames);\n      });\n      var asMatrix = math.config.matrix !== 'Array';\n      if (asMatrix) {\n        var matrix = math.matrix;\n        return function evalArrayNode(scope, args, context) {\n          return matrix(map(evalItems, function (evalItem) {\n            return evalItem(scope, args, context);\n          }));\n        };\n      } else {\n        return function evalArrayNode(scope, args, context) {\n          return map(evalItems, function (evalItem) {\n            return evalItem(scope, args, context);\n          });\n        };\n      }\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      for (var i = 0; i < this.items.length; i++) {\n        var node = this.items[i];\n        callback(node, 'items[' + i + ']', this);\n      }\n    }\n\n    /**\n     * Create a new ArrayNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {ArrayNode} Returns a transformed copy of the node\n     */\n    map(callback) {\n      var items = [];\n      for (var i = 0; i < this.items.length; i++) {\n        items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));\n      }\n      return new ArrayNode(items);\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {ArrayNode}\n     */\n    clone() {\n      return new ArrayNode(this.items.slice(0));\n    }\n\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     * @override\n     */\n    _toString(options) {\n      var items = this.items.map(function (node) {\n        return node.toString(options);\n      });\n      return '[' + items.join(', ') + ']';\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      return {\n        mathjs: name,\n        items: this.items\n      };\n    }\n\n    /**\n     * Instantiate an ArrayNode from its JSON representation\n     * @param {Object} json  An object structured like\n     *                       `{\"mathjs\": \"ArrayNode\", items: [...]}`,\n     *                       where mathjs is optional\n     * @returns {ArrayNode}\n     */\n    static fromJSON(json) {\n      return new ArrayNode(json.items);\n    }\n\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     * @override\n     */\n    toHTML(options) {\n      var items = this.items.map(function (node) {\n        return node.toHTML(options);\n      });\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + items.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n    _toTex(options) {\n      function itemsToTex(items, nested) {\n        var mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);\n        var itemsFormRow = nested || mixedItems;\n        var itemSep = itemsFormRow ? '&' : '\\\\\\\\';\n        var itemsTex = items.map(function (node) {\n          if (node.items) {\n            return itemsToTex(node.items, !nested);\n          } else {\n            return node.toTex(options);\n          }\n        }).join(itemSep);\n        return mixedItems || !itemsFormRow || itemsFormRow && !nested ? '\\\\begin{bmatrix}' + itemsTex + '\\\\end{bmatrix}' : itemsTex;\n      }\n      return itemsToTex(this.items, false);\n    }\n  }\n  _defineProperty(ArrayNode, \"name\", name);\n  return ArrayNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":null,"metadata":{},"sourceType":"module"}