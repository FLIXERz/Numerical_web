{"ast":null,"code":"import * as math from 'mathjs';\nconst i_arr = [];\nconst a_arr = [];\nconst b_arr = [];\nconst root_arr = [];\nexport default function regulaFalsi(a, b, eq) {\n  const Error_rate = 0.0000001;\n  function func(x) {\n    const node2 = math.parse(eq);\n    const code2 = node2.compile();\n    let scope = {\n      x\n    };\n    return code2.evaluate(scope);\n  }\n  function funcfls(a, b) {\n    return (a * func(b) - b * func(a)) / (func(b) - func(a));\n  }\n  let ix = 0;\n  let xm = a;\n  while (Math.abs(func(xm)) > Error_rate) {\n    a_arr.push(a);\n    b_arr.push(b);\n    xm = funcfls(a, b);\n\n    // Check if the above found point is root\n    if (func(xm) === 0) {\n      break;\n    } else if (func(xm) * func(a) < 0) {\n      b = xm;\n    } else {\n      a = xm;\n    }\n    ix++;\n    i_arr.push(ix);\n    root_arr.push(xm);\n\n    // Check if the change in the interval is small enough\n    if (Math.abs(b - a) < Error_rate) {\n      break;\n    }\n  }\n  return xm;\n}\nexport function DataTable(x) {\n  const data = [];\n  for (let i = 0; i < i_arr.length; i++) {\n    data.push({\n      iter: i_arr[i],\n      x0: a_arr[i],\n      x1: b_arr[i],\n      xm: root_arr[i]\n    });\n  }\n  if (x === 1) {\n    // Clear the existing data\n    data.length = 0;\n    // datax.length = 0;\n    i_arr.length = 0;\n    a_arr.length = 0;\n    b_arr.length = 0;\n    root_arr.length = 0;\n  }\n  return data;\n}","map":{"version":3,"names":["math","i_arr","a_arr","b_arr","root_arr","regulaFalsi","a","b","eq","Error_rate","func","x","node2","parse","code2","compile","scope","evaluate","funcfls","ix","xm","Math","abs","push","DataTable","data","i","length","iter","x0","x1"],"sources":["C:/Users/Azul/homework/Numerical/1/PJ/src/Components/Testflase.js"],"sourcesContent":["import * as math from 'mathjs';\r\n\r\nconst i_arr = [];\r\nconst a_arr = [];\r\nconst b_arr = [];\r\nconst root_arr = [];\r\n\r\nexport default function regulaFalsi(a, b, eq) {\r\n  const Error_rate = 0.0000001;\r\n\r\n  function func(x) {\r\n    const node2 = math.parse(eq);\r\n    const code2 = node2.compile();\r\n    let scope = { x };\r\n    return code2.evaluate(scope);\r\n  }\r\n\r\n  function funcfls(a, b) {\r\n    return (a * func(b) - b * func(a)) / (func(b) - func(a));\r\n  }\r\n\r\n  let ix = 0;\r\n  let xm = a;\r\n\r\n  while (Math.abs(func(xm)) > Error_rate) {\r\n    a_arr.push(a);\r\n    b_arr.push(b);\r\n\r\n    xm = funcfls(a, b);\r\n\r\n    // Check if the above found point is root\r\n    if (func(xm) === 0) {\r\n      break;\r\n    } else if (func(xm) * func(a) < 0) {\r\n      b = xm;\r\n    } else {\r\n      a = xm;\r\n    }\r\n\r\n    ix++;\r\n    i_arr.push(ix);\r\n    root_arr.push(xm);\r\n\r\n    // Check if the change in the interval is small enough\r\n    if (Math.abs(b - a) < Error_rate) {\r\n      break;\r\n    }\r\n  }\r\n  return xm;\r\n}\r\n\r\nexport function DataTable(x) {\r\n  const data = [];\r\n  for (let i = 0; i < i_arr.length; i++) {\r\n    data.push({ iter: i_arr[i], x0: a_arr[i], x1: b_arr[i], xm: root_arr[i] });\r\n  }\r\n\r\n  if(x === 1){\r\n    // Clear the existing data\r\n    data.length = 0;\r\n    // datax.length = 0;\r\n    i_arr.length = 0;\r\n    a_arr.length = 0;\r\n    b_arr.length = 0 ;\r\n    root_arr.length = 0;\r\n}\r\n  return data;\r\n}\r\n"],"mappings":"AAAA,OAAO,KAAKA,IAAI,MAAM,QAAQ;AAE9B,MAAMC,KAAK,GAAG,EAAE;AAChB,MAAMC,KAAK,GAAG,EAAE;AAChB,MAAMC,KAAK,GAAG,EAAE;AAChB,MAAMC,QAAQ,GAAG,EAAE;AAEnB,eAAe,SAASC,WAAWA,CAACC,CAAC,EAAEC,CAAC,EAAEC,EAAE,EAAE;EAC5C,MAAMC,UAAU,GAAG,SAAS;EAE5B,SAASC,IAAIA,CAACC,CAAC,EAAE;IACf,MAAMC,KAAK,GAAGZ,IAAI,CAACa,KAAK,CAACL,EAAE,CAAC;IAC5B,MAAMM,KAAK,GAAGF,KAAK,CAACG,OAAO,CAAC,CAAC;IAC7B,IAAIC,KAAK,GAAG;MAAEL;IAAE,CAAC;IACjB,OAAOG,KAAK,CAACG,QAAQ,CAACD,KAAK,CAAC;EAC9B;EAEA,SAASE,OAAOA,CAACZ,CAAC,EAAEC,CAAC,EAAE;IACrB,OAAO,CAACD,CAAC,GAAGI,IAAI,CAACH,CAAC,CAAC,GAAGA,CAAC,GAAGG,IAAI,CAACJ,CAAC,CAAC,KAAKI,IAAI,CAACH,CAAC,CAAC,GAAGG,IAAI,CAACJ,CAAC,CAAC,CAAC;EAC1D;EAEA,IAAIa,EAAE,GAAG,CAAC;EACV,IAAIC,EAAE,GAAGd,CAAC;EAEV,OAAOe,IAAI,CAACC,GAAG,CAACZ,IAAI,CAACU,EAAE,CAAC,CAAC,GAAGX,UAAU,EAAE;IACtCP,KAAK,CAACqB,IAAI,CAACjB,CAAC,CAAC;IACbH,KAAK,CAACoB,IAAI,CAAChB,CAAC,CAAC;IAEba,EAAE,GAAGF,OAAO,CAACZ,CAAC,EAAEC,CAAC,CAAC;;IAElB;IACA,IAAIG,IAAI,CAACU,EAAE,CAAC,KAAK,CAAC,EAAE;MAClB;IACF,CAAC,MAAM,IAAIV,IAAI,CAACU,EAAE,CAAC,GAAGV,IAAI,CAACJ,CAAC,CAAC,GAAG,CAAC,EAAE;MACjCC,CAAC,GAAGa,EAAE;IACR,CAAC,MAAM;MACLd,CAAC,GAAGc,EAAE;IACR;IAEAD,EAAE,EAAE;IACJlB,KAAK,CAACsB,IAAI,CAACJ,EAAE,CAAC;IACdf,QAAQ,CAACmB,IAAI,CAACH,EAAE,CAAC;;IAEjB;IACA,IAAIC,IAAI,CAACC,GAAG,CAACf,CAAC,GAAGD,CAAC,CAAC,GAAGG,UAAU,EAAE;MAChC;IACF;EACF;EACA,OAAOW,EAAE;AACX;AAEA,OAAO,SAASI,SAASA,CAACb,CAAC,EAAE;EAC3B,MAAMc,IAAI,GAAG,EAAE;EACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzB,KAAK,CAAC0B,MAAM,EAAED,CAAC,EAAE,EAAE;IACrCD,IAAI,CAACF,IAAI,CAAC;MAAEK,IAAI,EAAE3B,KAAK,CAACyB,CAAC,CAAC;MAAEG,EAAE,EAAE3B,KAAK,CAACwB,CAAC,CAAC;MAAEI,EAAE,EAAE3B,KAAK,CAACuB,CAAC,CAAC;MAAEN,EAAE,EAAEhB,QAAQ,CAACsB,CAAC;IAAE,CAAC,CAAC;EAC5E;EAEA,IAAGf,CAAC,KAAK,CAAC,EAAC;IACT;IACAc,IAAI,CAACE,MAAM,GAAG,CAAC;IACf;IACA1B,KAAK,CAAC0B,MAAM,GAAG,CAAC;IAChBzB,KAAK,CAACyB,MAAM,GAAG,CAAC;IAChBxB,KAAK,CAACwB,MAAM,GAAG,CAAC;IAChBvB,QAAQ,CAACuB,MAAM,GAAG,CAAC;EACvB;EACE,OAAOF,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module"}